package leetCode.oneMoreHundred;

import java.util.Arrays;

/**
 * @Date: 2020年8月17日
 * ==============================================================================
 * 621. 任务调度器
 * ==============================================================================
 * 给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。
 * 任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。
 *
 * 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
 *
 * 你需要计算完成所有任务所需要的最短时间。
 *
 *  
 *
 * 示例 ：
 *
 * 输入：tasks = ["A","A","A","B","B","B"], n = 2
 * 输出：8
 * 解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B.
 *      在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。
 *  
 *
 * 提示：
 *
 * 任务的总个数为 [1, 10000]。
 * n 的取值范围为 [0, 100]。
 * ==============================================================================
 */
public class Day018 {


    public static void main(String[] args) {
        char[] tasks = {'A','B','A','B','A','B'};
        System.out.println(new Day018().leastInterval(tasks,2));
    }


    /**
     * @Title: 621. 任务调度器
     * @Version: 版本1 数组排序解法
     *
     * (1) 任务输入数组为 'A' 到 ‘Z’ 范围内的字符, 很容易的想到可以使用长度为16的数组来统计不同任务的个数
     * 而不是使用 散列
     *
     * (2) 当 n 小于任务种类数时,需要有一种策略提前把出现次数较多的任务先执行 否则到最后就会出现出现次数较多的少数几个(假设为k个)任务
     * 每次执行需要占用 n+1 的执行时间，单个轮次就造成了 (n+1 - k) 的时间浪费; 现在这样就很有可能不是最短执行时间了。
     * 因此 每次执行完一轮(n+1个时间单位)后,就重新对任务出现次数做一次排序，然后优先执行出现次数最高的n+1个任务(如果还存在n+1个的话)
     * 执行完之后对应的任务所在槽位值-1；这样做可以确保每次执行都是n+1 的时间范围内多执行任务 得到执行时间也就是最短的执行时间。
     *
     * 需要注意的是: 一开始数组下标时可以和任务对应起来的，但是经过数组排序之后下标就不再和任务对应了；
     * 但是对于统计执行时间而言,每个时间上执行的是什么任务并不影响结果。
     *
     * (3) 同类任务间隔长度为 n 意味着每 n+1 个时间范围内不能出现重复的任务，但是由于 n的取值范围为[0-100],
     * n 可能大于26，因此除非所有任务都执行完了，从一开始就有可能有需要有"待命" 的空闲时间出现在 时间长度为(n+1)
     * 的轮询中
     *
     *
     * @param tasks
     * @param n
     * @return
     */
    public int leastInterval(char[] tasks, int n) {
        int[] taskMap = new int[26];
        for(char c : tasks){
            taskMap[c-'A'] += 1;
        }
        int minTime = 0;
        Arrays.sort(taskMap);
        while(taskMap[25] > 0){
            int i = 0;
            while(i <= n){
                if(i <= 25 && taskMap[25 - i] > 0){
                    taskMap[25 - i] -= 1;
                }else if(taskMap[25] == 0){
                    // 针对最后一次循环时只要执行完最后一个任务,就应该结束计数
                    break;
                }
                i++;
                minTime++;
            }
            Arrays.sort(taskMap);
        }
        return minTime;
    }

    /**
     * @Title: 621. 任务调度器
     * @Version: 版本2 优先队列解法
     * @param tasks
     * @param n
     * @return
     */
    public int leastInterval2(char[] tasks, int n) {
        return 0;
    }

}
