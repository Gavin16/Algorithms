package leetcode.oneMoreHundred;

/**
 * @Date： 2020年8月10日
 * ==============================================================================
 * 96. 不同的二叉搜索树
 * ==============================================================================
 * 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
 *
 * 示例:
 *
 * 输入: 3
 * 输出: 5
 * 解释:
 * 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:
 *
 *    1         3     3      2      1
 *     \       /     /      / \      \
 *      3     2     1      1   3      2
 *     /     /       \                 \
 *    2     1         2                 3
 * ==============================================================================
 *
 */
public class Day014 {


    public static void main(String[] args) {
        System.out.println(numTrees2(1));
        System.out.println(numTrees2(2));
        System.out.println(numTrees2(3));
        System.out.println(numTrees2(4));
        System.out.println(numTrees2(5));
    }

    /**
     * @Title: 96. 不同的二叉搜索树
     * @Version: 动态规划实现
     * 对于输入n得到的序列(1,2,3,4,...,n)考虑使用不同的元素作为二叉搜索树的根节点, 需要满足根节点左边的元素
     * 要小于根节点右边的元素,因此若选择 i(i >= 1) 作为根节点，那么左子树对应的元素为 1,2,..,i-1 共 i - 1 个
     * 相应的右子树的元素个数为 i+1,i+2,...,n 共 n-i 个;
     *
     * 考虑以上的规律,设 f(i) 为以i作为根节点时对应可以构建的搜索二叉树的个数,T(n) 代表 输入n 对应的不相同的二叉搜索树的个数，则
     * f(i) = T(i-1)*T(n-i)
     * 同时也有
     * T(n) = Σf(i) = ΣT(i-1)*T(n-i) (i = 1,2,3,..,n)
     * 因此对于输入n,其对应的不同二叉搜索树的个数满足以下 转移方程
     * T(n) = ΣT(i-1)*T(n-i) (i = 1,2,3,..,n)
     *
     * 对于n = 0 , 1 的情况，T(0) = 1, T(1) = 1
     *
     * @param n
     * @return
     */
    public static int numTrees(int n) {
        if(n <= 1){return 1;}
        int[] T = new int[n+1];
        T[0] = 1;T[1] = 1;

        for(int i = 2; i <= n ; i++){
            int curr = 0;
            for(int k = 1; k <= i ; k++){
                curr += T[k-1]*T[i-k];
            }
            T[i] = curr;
        }
        return T[n];
    }


    /**
     * @Title:  96. 不同的二叉搜索树
     * @Version: 卡特兰数公式实现
     *
     * 对于函数f(n),若满足f(n) = Σf(i-1)*f(n-i)  (i = 1,2,3,4,..,n)
     * 则 f(n) 被称为卡特兰数,对于卡特兰数，有如下递推公式
     *
     * f(n) = C(2*n,n)/n+1
     * f(n+1) = C(2*(n+1),n+1)/n+2 = (2*(2n+1)/(n+2))*f(n)
     *
     * 故对于任意输入n ,求对应不同的二叉搜索树的个数满足如下递推公式
     * f(n+1) = (2*(2n+1)/(n+2))*f(n)
     * 也即：
     * f(n) = (2*(2n-1)/(n+1))*f(n-1)
     *
     * @param n
     * @return
     */
    public static int numTrees2(int n){
        long c  = 1;
        for(int k = 2 ; k <= n ; k++){
            c =  2 * c * (2 * k - 1)/(k + 1);
        }
        return (int)c;
    }

    /**
     * 常见卡特兰数问题
     * (1) 求合法的括号序列的个数
     * (2) 求带限制条件的路径条数
     * (3) 假设1,2,3,… ,N ; N个数按照顺序进栈,那么他们出栈的排列总数有多少种
     *     设f(N) 代表总的出栈的可能数(排列数)
     *     假设第k个元素最后出栈,那么比元素k早进早出的元素个数对应的排列数为f(k-1)，比元素k晚进早出的元素对应的排列数为f(N-k)
     *     那么可以得到 若元素k最后出栈,那么对应的出栈的可能排列数为f(k-1)*f(N-k);
     *     对于 1,2,3,…,N 所有的元素,每个元素都可能是最后出栈的那个,那么对应的各种情况的和就是 f(N)
     *     从而得到 f(N) = Σf(k-1)*f(n-k) (k=1,2,3,…,N)
     *
     *     由此可知 所有出栈的总数个数为 卡特兰数
     *
     * (4) n+m个人排队买票，假设售票点无零钱，n+m 中n人有5元m人有10元,所有人都能买到票问题
     * (5) 火车出站问题
     *
     *
     *
     *
     */
}
