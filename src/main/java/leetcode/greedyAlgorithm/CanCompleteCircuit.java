package leetcode.greedyAlgorithm;

/**
 * 《134. 加油站》
 *  在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
 *
 * 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
 *
 * 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
 *
 * 说明: 
 *
 * 如果题目有解，该答案即为唯一答案。
 * 输入数组均为非空数组，且长度相同。
 * 输入数组中的元素均为非负数。
 * 示例 1:
 *
 * 输入:
 * gas  = [1,2,3,4,5]
 * cost = [3,4,5,1,2]
 *
 * 输出: 3
 *
 * 解释:
 * 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
 * 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
 * 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
 * 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
 * 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
 * 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
 * 因此 3 可为起始索引。
 * 示例 2:
 *
 * 输入:
 * gas  = [2,3,4]
 * cost = [3,4,3]
 *
 * 输出: -1
 *
 * 解释:
 * 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
 * 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
 * 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
 * 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
 * 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
 * 因此，无论怎样，你都不可能绕环路行驶一周。
 *
 *
 *
 */
public class CanCompleteCircuit {

    /**
     *
     * 注意：本题和 interviewQuestions.GasBusStartPosition 是同一个题
     * GasBusStartPosition 中时间复杂度为 O(n^2)
     *
     */
    public static void main(String[] args) {
    }

    /**
     *  问题分析:
     *  (1) 如果 cost数组的和 大于  gas 数组的和； 那么可以确定无论从哪里出发都不能绕一圈
     *  (2) 如果从k的位置出发，但是cost[k] > gas[k], 这时无法出发则跳过 k 位置
     *  (3) 当从 j 位置 开到k位置没油时, 这时应该将出发位置设置为 k+1, 因为中间经过的位置，每个位置在经过前的剩余油量都满足 sum(gas) >= 0 ，
     *  如果将出发位置选在这中间位置譬如 l, 那么在经过l前的剩余油量为空， 对于之前的 >= 0 的情况都无法通过k, 从中间开始则更加不能通过 k
     *  (4) 若gas 所有油的总和大于 cost 的消耗总和，那么一定存在一个位置，从该位置出发定能绕完整一圈
     *          假设从0 的位置开始出发，走到中途某个 k的位置油不够了，那么一定有 gas[0:k] 的油量 < cost[0:k]的油量，
     *          从而可以得出 gas[k+1,end] 油量 > cost[k+1,end]的油量，那么一定存在某个位置开始可以一直开到end位置，此时开到end
     *          依然还是会有剩油，当利用剩油一直开到k的位置时，那么之后还能否经过位置k呢？？
     *          答案是肯定的，因为之前跳过的单个位置或者区间位置都满足 加油量 < 耗油量，这样把这些位置的加油量加起来肯定 小于 耗油量的和。
     *          假设 之前的耗油量 - 加油量 = n. 那么从后面的某一个位置(假设该位置记为p)起一定存在某一个位置或者某一个区间 加油量之和 - 耗油量之和 >= n;
     *          （当区间从p位置起时 取等号）
     */
    public static int canCompleteCircuit(int[] gas, int[] cost) {
        int gasSum = 0 , costSum = 0;
        for(int i = 0; i < gas.length ; i++)
            gasSum += gas[i];
        for(int j = 0 ; j < cost.length ; j++)
            costSum += cost[j];
        if(costSum > gasSum) return -1;


        int gasLeft = 0,startPos = 0;
        for(int k = 0 ; k < gas.length ; k++){
            gasLeft += gas[k] - cost[k];
            if(gasLeft < 0){
                startPos = k+1;
                gasLeft = 0;
            }
        }

        return startPos;
    }

}

